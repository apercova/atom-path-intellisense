<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: providers/current-file-relative-path.provider.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: providers/current-file-relative-path.provider.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const path = require('path');
const fs = require('fs');
const settings = require('../config/settings');
const consts = require('../config/consts');
const logger = require('../util/logger');
const BasePathProvider = require('./base-path.provider');
const BaseFormatter = require('../formatters/base.formatter');
const DefaultFormatter = require('../formatters/default.formatter');
const SearchPathDTO = require('../dto/search-path.dto');

class CurrentFileRelativePathProvider extends BasePathProvider {
    constructor(formatter) {
        super();
        this.id = 'CurrentFileRelativePathProvider';
        this.priority = 9997;
        this.scopeSelector = settings[`${consts.CF_ALLOWED_SCOPES}`].default;
        this.formatter =
            formatter instanceof BaseFormatter
                ? formatter
                : new DefaultFormatter();
        this._logger = logger.getLogger(this.id);
        this._relPathRegex = /(\/|~\/|\.\/|\.\.\/)/;
        this._prefixRegex = /[^/]+$/;

    }

    /**
     * canResolve - Determines wether this provider can resolve suggestions
     *
     * @param  {object} req Request options
     * @return {object}     {@code true} if this provider can resolve suggestions. {@code false} otherwise
     */
    canResolve(req) {
        return this.$getCurrentLineUpCursor(req, true).match(this._relPathRegex)
            ? true
            : false;
    }

    /**
     * resolve - Resolve suggestions
     *
     * @param  {object} req Request options
     * @return {object}     Autocomplete suggestions
     */
    resolve(req) {
        return this.$resolveSuggestions(
            req,
            this._resolveValidPathSync(
                this,
                req,
                this.$getCurrentLineUpCursor(req, true)
            )
        );
    }

    /**
     * _resolveValidPathSync - Recursively resolves search path from test string
     *
     * @param  {BasePathProvider} $self    Self reference
     * @param  {object} req                Request options
     * @param  {string} testPath           String to test for path recognition
     * @param  {string} searchPath         Found search path
     * @param  {string} basePath           Search base path
     * @param  {number} idx                Iteration count index
     * @return {SearchPathDTO}             Found search path props
     */
    _resolveValidPathSync($self, req, testPath, searchPath, basePath, idx) {
        if (searchPath) {
            return new SearchPathDTO(basePath, searchPath, testPath);
        }
        if (!testPath &amp;&amp; !searchPath) {
            return false;
        }

        idx = !isNaN(idx) ? idx : 0;
        idx++;
        testPath = testPath || '';
        $self._logger.debug(`testPath: ${testPath}`);
        const matches = testPath.match($self._relPathRegex);
        if (!matches || !matches[0]) {
            return false;
        }

        testPath = testPath.substring(matches.index);
        $self._logger.debug(`trying ${testPath}`);

        basePath = testPath.startsWith('~/')
            ? $self.$getHomedir()
            : testPath.startsWith('/')
                ? $self.$getCurrentProjectPath(req, true)
                : $self.$getCurrentFilePath(req, true);
        $self._logger.debug(`basepath: ${basePath}`);

        let fullTestPath = testPath.startsWith('~/')
            ? path.normalize(path.join(basePath, testPath.replace(/^~\//, '')))
            : path.normalize(path.join(basePath, testPath));

        $self._logger.debug(`full path resolved as: ${fullTestPath}`);
        /* Validating existence as file or directory */
        try {
            fs.accessSync(fullTestPath, fs.constants.F_OK);
            $self._logger.debug(`${fullTestPath} does exist as file or dir`);
            /* Path does exist, validate if file or dir */
            let stats = fs.statSync(fullTestPath);
            if (!stats.isDirectory()) {
                $self._logger.debug(`${fullTestPath} is a file`);
                fullTestPath = path.parse(fullTestPath).dir;
                return $self._resolveValidPathSync(
                    $self,
                    req,
                    testPath,
                    fullTestPath,
                    basePath,
                    idx
                );
            } else {
                $self._logger.debug(`${fullTestPath} is a dir`);
                if (testPath.endsWith('/')) {
                    return $self._resolveValidPathSync(
                        $self,
                        req,
                        testPath,
                        fullTestPath,
                        basePath,
                        idx
                    );
                } else {
                    /*
                     * Fix to allow searching existing directory while not specifying
                     * forward slash in order to avoid change back directory when use
                     * back directory name (..)
                     */
                    fullTestPath = path.parse(fullTestPath).dir;
                    return $self._resolveValidPathSync(
                        $self,
                        req,
                        testPath,
                        fullTestPath,
                        basePath,
                        idx
                    );
                }
            }
        } catch (e) {
            $self._logger.warn(e);
            $self._logger.debug(
                `${fullTestPath} does not exist as file nor dir`
            );
            /* testPath neither exists as file nor directory
             * Validating existence of parent directory */
            if (!testPath.endsWith('/')) {
                /* Prevents searching on parent directory if test path is a directory */
                fullTestPath = path.parse(fullTestPath).dir;
                try {
                    fs.accessSync(fullTestPath, fs.constants.F_OK);
                    $self._logger.debug(
                        `${fullTestPath} does exist as parent dir`
                    );
                    /* Path exists as parent dir, return match */
                    return $self._resolveValidPathSync(
                        $self,
                        req,
                        testPath,
                        fullTestPath,
                        basePath,
                        idx
                    );
                } catch (e) {
                    $self._logger.warn(e);
                    $self._logger.debug(
                        `${fullTestPath} does not exist as parent dir`
                    );
                    /* Path does not exist as parent dir, trying next match */
                    testPath = testPath.substring(matches[0].length);
                    return $self._resolveValidPathSync(
                        $self,
                        req,
                        testPath,
                        '',
                        basePath,
                        idx
                    );
                }
            } else {
                /* No path exists at all, trying next match */
                testPath = testPath.substring(matches[0].length);
                return $self._resolveValidPathSync(
                    $self,
                    req,
                    testPath,
                    '',
                    basePath,
                    idx
                );
            }
        }
    }

    /**
     * $getPrefix - Return replacement prefix
     *
     * @param  {object}        req    Request options
     * @param  {SearchPathDTO} search Search options
     * @return {string}               Replacement prefix
     */
    $getPrefix(req, search) {
        let prefix = '';
        if (search instanceof SearchPathDTO) {
            const match = search.testPath.match(this._prefixRegex);
            prefix = match ? match[0] : '';
        }
        return prefix;
    }
}
CurrentFileRelativePathProvider.id = 'CurrentFileRelativePathProvider';
module.exports = CurrentFileRelativePathProvider;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-config_config.html">config/config</a></li><li><a href="module-config_consts.html">config/consts</a></li><li><a href="module-config_settings.html">config/settings</a></li><li><a href="module-dto_SearchPathDTO.html">dto/SearchPathDTO</a></li></ul><h3>Classes</h3><ul><li><a href="BaseFormatter.html">BaseFormatter</a></li><li><a href="BasePathProvider.html">BasePathProvider</a></li><li><a href="DefaultFormatter.html">DefaultFormatter</a></li><li><a href="module-dto_SearchPathDTO-SearchPathDTO.html">SearchPathDTO</a></li><li><a href="NodeJSFormatter.html">NodeJSFormatter</a></li><li><a href="SuggestionsDTO.html">SuggestionsDTO</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Mon Oct 21 2019 21:43:26 GMT-0500 (Hora de verano central (MÃ©xico))
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
